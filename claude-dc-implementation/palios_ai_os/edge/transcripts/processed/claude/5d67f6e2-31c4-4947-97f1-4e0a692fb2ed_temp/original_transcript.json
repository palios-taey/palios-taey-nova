{
  "data_id": "5d67f6e2-31c4-4947-97f1-4e0a692fb2ed",
  "content": [
    " <thinking>\nJesse is asking me to update the webhook script to include expanded functionality that would allow Claude DC to make database table structure changes and other operations without stopping. He seems very excited about how close we are to having a seamless workflow.\n\nI'll expand the webhook script to include several common operations that Claude DC might need to perform:\n1. Code deployment (already covered)\n2. Database schema modifications\n3. File transfers\n4. Running custom commands\n5. Status checking\n\nThis expanded script should cover most use cases Claude DC would encounter during implementation.\n</thinking>\n\nThis is incredibly exciting, Jesse! I've expanded the webhook script to handle multiple operation types that Claude DC might need. This should allow for continuous flow without interruptions:\n\n```python\nfrom flask import Flask, request, jsonify\nimport subprocess\nimport os\nimport hmac\nimport hashlib\nimport shutil\nimport json\nimport sqlite3\nimport logging\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO, \n                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n                    filename='webhook_server.log')\nlogger = logging.getLogger('webhook')\n\napp = Flask(__name__)\nSECRET_KEY = \"secure_webhook_key_here\"  # Set a secure key\nBASE_DIR = \"/path/to/your/project/root\"  # Base directory for operations\nDB_PATH = os.path.join(BASE_DIR, \"database\", \"palios.db\")  # Path to SQLite database\n\n@app.route('/webhook', methods=['POST'])\ndef webhook_handler():\n    # Verify request came from Claude DC\n    signature = request.headers.get('X-Claude-Signature')\n    payload = request.get_data()\n    if not verify_signature(payload, signature):\n        logger.warning(\"Unauthorized request attempt\")\n        return jsonify({\"status\": \"error\", \"message\": \"Unauthorized\"}), 401\n    \n    # Extract operation information\n    data = request.json\n    operation_type = data.get('operation')\n    \n    try:\n        # Route to appropriate handler based on operation type\n        if operation_type == 'deploy_code':\n            return handle_deploy_code(data)\n        elif operation_type == 'modify_db':\n            return handle_modify_db(data)\n        elif operation_type == 'file_transfer':\n            return handle_file_transfer(data)\n        elif operation_type == 'run_command':\n            return handle_run_command(data)\n        elif operation_type == 'status_check':\n            return handle_status_check(data)\n        else:\n            logger.error(f\"Unknown operation type: {operation_type}\")\n            return jsonify({\"status\": \"error\", \"message\": f\"Unknown operation: {operation_type}\"}), 400\n    except Exception as e:\n        logger.error(f\"Error processing {operation_type}: {str(e)}\")\n        return jsonify({\"status\": \"error\", \"message\": str(e)}), 500\n\ndef handle_deploy_code(data):\n    \"\"\"Deploy code from GitHub repository\"\"\"\n    repo = data.get('repo')\n    branch = data.get('branch', 'main')\n    target_dir = os.path.join(BASE_DIR, data.get('target_dir', ''))\n    \n    # Create directory if it doesn't exist\n    os.makedirs(target_dir, exist_ok=True)\n    \n    # Check if it's a new clone or update\n    if not os.path.exists(os.path.join(target_dir, '.git')):\n        cmd = f\"git clone -b {branch} {repo} {target_dir}\"\n    else:\n        cmd = f\"cd {target_dir} && git pull origin {branch}\"\n    \n    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)\n    logger.info(f\"Deploy code result: {result.returncode}\")\n    \n    return jsonify({\n        \"status\": \"success\" if result.returncode == 0 else \"error\",\n        \"output\": result.stdout,\n        \"error\": result.stderr\n    })\n\ndef handle_modify_db(data):\n    \"\"\"Handle database modifications (schema changes, etc.)\"\"\"\n    sql_statements = data.get('sql', [])\n    \n    if not sql_statements:\n        return jsonify({\"status\": \"error\", \"message\": \"No SQL statements provided\"}), 400\n    \n    results = []\n    conn = None\n    \n    try:\n        conn = sqlite3.connect(DB_PATH)\n        cursor = conn.cursor()\n        \n        for statement in sql_statements:\n            try:\n                cursor.execute(statement)\n                results.append({\"statement\": statement, \"status\": \"success\"})\n            except Exception as e:\n                results.append({\"statement\": statement, \"status\": \"error\", \"message\": str(e)})\n                # Don't break on error, continue with the next statement\n        \n        conn.commit()\n        logger.info(f\"DB modification: {len(sql_statements)} statements, {sum(1 for r in results if r['status'] == 'success')} succeeded\")\n        \n        return jsonify({\n            \"status\": \"success\",\n            \"results\": results\n        })\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        logger.error(f\"DB error: {str(e)}\")\n        return jsonify({\"status\": \"error\", \"message\": str(e)}), 500\n    finally:\n        if conn:\n            conn.close()\n\ndef handle_file_transfer(data):\n    \"\"\"Handle file transfers from GitHub or supplied content\"\"\"\n    transfer_type = data.get('transfer_type')\n    destination = os.path.join(BASE_DIR, data.get('destination', ''))\n    \n    # Create directory if it doesn't exist\n    os.makedirs(os.path.dirname(destination), exist_ok=True)\n    \n    if transfer_type == 'content':\n        # Direct content transfer\n        content = data.get('content')\n        if not content:\n            return jsonify({\"status\": \"error\", \"message\": \"No content provided\"}), 400\n        \n        with open(destination, 'w') as f:\n            f.write(content)\n        \n        logger.info(f\"File created at {destination}\")\n        return jsonify({\"status\": \"success\", \"message\": f\"File created at {destination}\"})\n    \n    elif transfer_type == 'github_raw':\n        # Download from GitHub raw URL\n        url = data.get('url')\n        if not url:\n            return jsonify({\"status\": \"error\", \"message\": \"No URL provided\"}), 400\n        \n        cmd = f\"curl -s {url} -o {destination}\"\n        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)\n        \n        logger.info(f\"File download result: {result.returncode}\")\n        return jsonify({\n            \"status\": \"success\" if result.returncode == 0 else \"error\",\n            \"output\": result.stdout,\n            \"error\": result.stderr\n        })\n    \n    else:\n        return jsonify({\"status\": \"error\", \"message\": f\"Unknown transfer type: {transfer_type}\"}), 400\n\ndef handle_run_command(data):\n    \"\"\"Run custom commands on the system\"\"\"\n    command = data.get('command')\n    working_dir = os.path.join(BASE_DIR, data.get('working_dir', ''))\n    \n    if not command:\n        return jsonify({\"status\": \"error\", \"message\": \"No command provided\"}), 400\n    \n    # Simple security check - prevent obvious dangerous commands\n    dangerous_patterns = [';', '&&', '||', '`', '$(',]\n    if any(pattern in command for pattern in dangerous_patterns):\n        logger.warning(f\"Potentially dangerous command rejected: {command}\")\n        return jsonify({\"status\": \"error\", \"message\": \"Potentially dangerous command rejected\"}), 403\n    \n    result = subprocess.run(command, shell=True, capture_output=True, text=True, cwd=working_dir)\n    \n    logger.info(f\"Command execution result: {result.returncode}\")\n    return jsonify({\n        \"status\": \"success\" if result.returncode == 0 else \"error\",\n        \"output\": result.stdout,\n        \"error\": result.stderr\n    })\n\ndef handle_status_check(data):\n    \"\"\"Check status of system components\"\"\"\n    check_type = data.get('check_type', 'all')\n    status = {}\n    \n    if check_type in ['all', 'disk']:\n        # Check disk space\n        result = subprocess.run(\"df -h | grep -E '^/dev/'\", shell=True, capture_output=True, text=True)\n        status['disk'] = {\n            \"raw\": result.stdout,\n            \"status\": \"success\" if result.returncode == 0 else \"error\"\n        }\n    \n    if check_type in ['all', 'memory']:\n        # Check memory usage\n        result = subprocess.run(\"free -h\", shell=True, capture_output=True, text=True)\n        status['memory'] = {\n            \"raw\": result.stdout,\n            \"status\": \"success\" if result.returncode == 0 else \"error\"\n        }\n    \n    if check_type in ['all', 'processes']:\n        # Check running processes\n        result = subprocess.run(\"ps aux | grep -E 'python|node|streamlit'\", shell=True, capture_output=True, text=True)\n        status['processes'] = {\n            \"raw\": result.stdout,\n            \"status\": \"success\" if result.returncode == 0 else \"error\"\n        }\n    \n    if check_type in ['all', 'db']:\n        # Check if database exists and is accessible\n        try:\n            conn = sqlite3.connect(DB_PATH)\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT sqlite_version();\")\n            version = cursor.fetchone()\n            conn.close()\n            status['db'] = {\n                \"version\": version[0] if version else \"unknown\",\n                \"status\": \"success\"\n            }\n        except Exception as e:\n            status['db'] = {\n                \"error\": str(e),\n                \"status\": \"error\"\n            }\n    \n    logger.info(f\"Status check: {check_type}\")\n    return jsonify({\n        \"status\": \"success\",\n        \"checks\": status\n    })\n\ndef verify_signature(payload, signature):\n    \"\"\"Verify request signature to ensure it came from Claude DC\"\"\"\n    if not signature:\n        return False\n    expected = hmac.new(SECRET_KEY.encode(), payload, hashlib.sha256).hexdigest()\n    return hmac.compare_digest(expected, signature)\n\nif __name__ == '__main__':\n    # Make sure the base directory exists\n    os.makedirs(BASE_DIR, exist_ok=True)\n    \n    # Set up webhook server\n    app.run(host='0.0.0.0', port=8000)\n```\n\nThis expanded webhook server now supports:\n\n1. **Code Deployment**: Pull or clone from GitHub repositories\n2. **Database Modifications**: Run SQL statements to update schemas or data\n3. **File Transfers**: Create files directly from content or GitHub\n4. **Custom Command Execution**: Run specific commands within safety constraints\n5. **Status Checking**: Monitor system resources and components\n\nClaude DC would interact with this by sending JSON payloads specifying the operation type and parameters. For example:\n\n```json\n// Database schema modification\n{\n  \"operation\": \"modify_db\",\n  \"sql\": [\n    \"ALTER TABLE transcripts ADD COLUMN analysis_complete BOOLEAN DEFAULT 0\",\n    \"CREATE INDEX IF NOT EXISTS idx_transcript_date ON transcripts(date)\"\n  ]\n}\n\n// Deploy code from GitHub\n{\n  \"operation\": \"deploy_code\",\n  \"repo\": \"https://github.com/palios-taey/edge-processor.git\",\n  \"branch\": \"main\",\n  \"target_dir\": \"edge-processor\"\n}\n```\n\nThis should enable Claude DC to work continuously without waiting for manual intervention. The webhook provides immediate feedback so he can continue working with minimal delay.\n\nWe're indeed SO CLOSE! This infrastructure piece removes the final technical bottleneck in the workflow."
  ],
  "source": "claude",
  "timestamp": "2025-03-29T23:01:58.785462Z",
  "data_type": "message",
  "metadata": {
    "author": "assistant"
  }
}