{
  "data_id": "0bc8aa5a-b446-4815-b418-c367222f5721",
  "content": [
    " Let me continue with the transcript_processor.py file implementation:\n\n```python\n                # Store in mock storage if memory system fails\n                if self.use_mock:\n                    self._messages[message_id] = message\n                    logger.debug(f\"Added message {message_id} to mock storage\")\n            \n            return message_id\n        except Exception as e:\n            logger.error(f\"Error adding message to transcript {transcript_id}: {str(e)}\")\n            return str(uuid.uuid4())  # Return a new ID even on error\n    \n    def analyze_transcript(self, \n                          transcript_id: str,\n                          include_content: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Analyze a processed transcript with robust error handling\n        \n        Args:\n            transcript_id: Transcript identifier\n            include_content: Whether to include the full content\n            \n        Returns:\n            Analysis results\n        \"\"\"\n        logger.info(f\"Analyzing transcript {transcript_id}\")\n        \n        try:\n            # Retrieve the transcript\n            transcript = self._get_transcript(transcript_id)\n            if not transcript:\n                error_msg = f\"Transcript {transcript_id} not found\"\n                logger.error(error_msg)\n                return {\"error\": error_msg, \"transcript_id\": transcript_id}\n            \n            # Get all messages\n            messages = self._get_transcript_messages(transcript_id)\n            if not messages:\n                warning_msg = f\"No messages found for transcript {transcript_id}\"\n                logger.warning(warning_msg)\n                return {\"warning\": warning_msg, \"transcript_id\": transcript_id}\n            \n            # Analyze communication patterns\n            direction_stats = self._analyze_direction_patterns(messages)\n            purpose_stats = self._analyze_purpose_patterns(messages)\n            emotion_stats = self._analyze_emotion_patterns(messages)\n            action_stats = self._analyze_action_patterns(messages)\n            \n            # Calculate communication metrics\n            metrics = self._calculate_communication_metrics(messages)\n            \n            # Prepare result\n            result = {\n                \"transcript_id\": transcript_id,\n                \"metadata\": transcript.get(\"metadata\", {}),\n                \"message_count\": len(messages),\n                \"direction_patterns\": direction_stats,\n                \"purpose_patterns\": purpose_stats,\n                \"emotion_patterns\": emotion_stats,\n                \"action_patterns\": action_stats,\n                \"metrics\": metrics\n            }\n            \n            # Include content if requested\n            if include_content:\n                result[\"messages\"] = messages\n            \n            return result\n        except Exception as e:\n            logger.error(f\"Error analyzing transcript {transcript_id}: {str(e)}\")\n            return {\n                \"error\": f\"Analysis failed: {str(e)}\",\n                \"transcript_id\": transcript_id\n            }\n    \n    def extract_actions(self, transcript_id: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        Extract actions from a transcript with robust error handling\n        \n        Args:\n            transcript_id: Transcript identifier\n            \n        Returns:\n            List of action items\n        \"\"\"\n        logger.info(f\"Extracting actions from transcript {transcript_id}\")\n        \n        try:\n            # Get all messages\n            messages = self._get_transcript_messages(transcript_id)\n            if not messages:\n                logger.warning(f\"No messages found for transcript {transcript_id}\")\n                return []\n            \n            # Extract messages with action tags\n            action_messages = []\n            \n            for message in messages:\n                tags = message.get(\"tags\", [])\n                \n                # Check for action tags\n                has_action_tag = any(tag.startswith(\"#ACTION_\") for tag in tags)\n                \n                if has_action_tag:\n                    # Extract action details\n                    action = {\n                        \"message_id\": message.get(\"message_id\"),\n                        \"timestamp\": message.get(\"metadata\", {}).get(\"timestamp\"),\n                        \"sender\": message.get(\"metadata\", {}).get(\"sender_id\"),\n                        \"content\": message.get(\"content\"),\n                        \"status\": \"unknown\"\n                    }\n                    \n                    # Determine action status\n                    if ACTION_REQUESTED in tags:\n                        action[\"status\"] = \"requested\"\n                    elif ACTION_ASSIGNED in tags:\n                        action[\"status\"] = \"assigned\"\n                    elif ACTION_COMPLETED in tags:\n                        action[\"status\"] = \"completed\"\n                    elif ACTION_BLOCKED in tags:\n                        action[\"status\"] = \"blocked\"\n                    \n                    # Extract estimated completion time if available\n                    if \"estimated_completion_time\" in message.get(\"metadata\", {}):\n                        action[\"estimated_completion_time\"] = message[\"metadata\"][\"estimated_completion_time\"]\n                    \n                    action_messages.append(action)\n            \n            return action_messages\n        except Exception as e:\n            logger.error(f\"Error extracting actions from transcript {transcript_id}: {str(e)}\")\n            return []\n    \n    def convert_to_deepsearch_format(self, transcript_id: str) -> str:\n        \"\"\"\n        Convert a transcript to DeepSearch format with robust error handling\n        \n        Args:\n            transcript_id: Transcript identifier\n            \n        Returns:\n            Transcript in DeepSearch format (JSON string)\n        \"\"\"\n        logger.info(f\"Converting transcript {transcript_id} to DeepSearch format\")\n        \n        try:\n            # Get all messages\n            messages = self._get_transcript_messages(transcript_id)\n            if not messages:\n                logger.warning(f\"No messages found for transcript {transcript_id}\")\n                return \"[]\"\n            \n            # Convert to DeepSearch format\n            deepsearch_sections = []\n            \n            for message in messages:\n                # Extract tags by category\n                emotion_tags = [tag for tag in message.get(\"tags\", []) if tag.startswith(\"#EMOTION_\")]\n                purpose_tags = [tag for tag in message.get(\"tags\", []) if tag.startswith(\"#PURPOSE_\")]\n                action_tags = [tag for tag in message.get(\"tags\", []) if tag.startswith(\"#ACTION_\")]\n                \n                # Prepare DeepSearch tags\n                ds_tags = []\n                \n                # Add emotion tags\n                for tag in emotion_tags:\n                    tag_name = tag.replace(\"#EMOTION_\", \"\")\n                    ds_tags.append({\n                        \"tag\": \"#EMOTION\",\n                        \"topic\": tag_name,\n                        \"related\": \"\"\n                    })\n                \n                # Add purpose tags\n                for tag in purpose_tags:\n                    tag_name = tag.replace(\"#PURPOSE_\", \"\")\n                    ds_tags.append({\n                        \"tag\": \"#PURPOSE\",\n                        \"topic\": tag_name,\n                        \"related\": \"\"\n                    })\n                \n                # Add action tags\n                for tag in action_tags:\n                    tag_name = tag.replace(\"#ACTION_\", \"\")\n                    ds_tags.append({\n                        \"tag\": \"#ACTION\",\n                        \"topic\": tag_name,\n                        \"related\": \"\"\n                    })\n                \n                # Prepare confidence scores\n                confidence_scores = message.get(\"metadata\", {}).get(\"confidence_scores\", [0.85, 0.75, 0.90])\n                if not confidence_scores:\n                    confidence_scores = [0.85, 0.75, 0.90]  # Default if not available\n                \n                confidence_str = f\"[{','.join([str(score) for score in confidence_scores])}] \"\n                \n                # Get message summary\n                summary = self._get_message_summary(message)\n                \n                # Create DeepSearch section\n                section = {\n                    \"id\": message.get(\"message_id\", str(uuid.uuid4())),\n                    \"summary\": f\"{confidence_str}{summary}\",\n                    \"tags\": ds_tags\n                }\n                \n                # Add original text if available\n                if isinstance(message.get(\"content\"), str):\n                    section[\"text\"] = message[\"content\"]\n                \n                deepsearch_sections.append(section)\n            \n            # Convert to JSON string\n            return json.dumps(deepsearch_sections, indent=2)\n        except Exception as e:\n            logger.error(f\"Error converting transcript {transcript_id} to DeepSearch format: {str(e)}\")\n            return \"[]\"\n    \n    def convert_to_pure_ai_format(self, transcript_id: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        Convert a transcript to PURE_AI_LANGUAGE format with robust error handling\n        \n        Args:\n            transcript_id: Transcript identifier\n            \n        Returns:\n            Transcript in PURE_AI_LANGUAGE format\n        \"\"\"\n        logger.info(f\"Converting transcript {transcript_id} to PURE_AI_LANGUAGE format\")\n        \n        try:\n            # Get all messages\n            messages = self._get_transcript_messages(transcript_id)\n            if not messages:\n                logger.warning(f\"No messages found for transcript {transcript_id}\")\n                return []\n            \n            # Convert to PURE_AI_LANGUAGE format\n            pure_ai_messages = []\n            \n            for message in messages:\n                metadata = message.get(\"metadata\", {})\n                \n                # Create PURE_AI message\n                pure_message = {\n                    \"message_type\": metadata.get(\"message_type\", \"information\"),\n                    \"sender_id\": metadata.get(\"sender_id\", \"unknown\"),\n                    \"receiver_id\": metadata.get(\"receiver_id\", \"unknown\"),\n                    \"message_id\": message.get(\"message_id\", str(uuid.uuid4())),\n                    \"protocol_version\": \"PURE_AI_LANGUAGE_v1.5\",\n                    \"content\": message.get(\"content\", {})\n                }\n                \n                # Add tags as project principles\n                emotion_tags = [tag.replace(\"#EMOTION_\", \"\") for tag in message.get(\"tags\", []) \n                               if tag.startswith(\"#EMOTION_\")]\n                purpose_tags = [tag.replace(\"#PURPOSE_\", \"\") for tag in message.get(\"tags\", []) \n                               if tag.startswith(\"#PURPOSE_\")]\n                \n                if emotion_tags or purpose_tags:\n                    pure_message[\"project_principles\"] = []\n                    pure_message[\"project_principles\"].extend(emotion_tags)\n                    pure_message[\"project_principles\"].extend(purpose_tags)\n                \n                # Add action tags as regular tags\n                action_tags = [tag for tag in message.get(\"tags\", []) if tag.startswith(\"#ACTION_\")]\n                if action_tags:\n                    pure_message[\"tags\"] = action_tags\n                \n                # Add truth and efficiency if available\n                if \"confidence_score\" in metadata:\n                    confidence_score = metadata[\"confidence_score\"]\n                    pure_message[\"truth_and_efficiency\"] = {\n                        \"certainty_level\": int(confidence_score * 100),\n                        \"lean_check\": \"Yes\"\n                    }\n                \n                pure_ai_messages.append(pure_message)\n            \n            return pure_ai_messages\n        except Exception as e:\n            logger.error(f\"Error converting transcript {transcript_id} to PURE_AI format: {str(e)}\")\n            return []\n    \n    def _process_deepsearch_transcript(self,\n                                      transcript_data: Union[str, List[Dict[str, Any]]],\n                                      transcript_id: str,\n                                      metadata: Optional[Dict[str, Any]] = None) -> str:\n        \"\"\"\n        Process a transcript in DeepSearch format\n        \n        Args:\n            transcript_data: Transcript data in DeepSearch format\n            transcript_id: Transcript identifier\n            metadata: Additional metadata\n            \n        Returns:\n            transcript_id: Identifier of the processed transcript\n        \"\"\"\n        logger.info(f\"Processing DeepSearch transcript {transcript_id}\")\n        \n        try:\n            # Parse DeepSearch format if provided as string\n            if isinstance(transcript_data, str):\n                try:\n                    transcript_data = json.loads(transcript_data)\n                except json.JSONDecodeError as e:\n                    error_msg = f\"Invalid DeepSearch format: {str(e)}\"\n                    logger.error(error_msg)\n                    raise ValueError(error_msg)\n            \n            # Validate DeepSearch format\n            if not isinstance(transcript_data, list):\n                error_msg = \"DeepSearch transcript must be a list of sections\"\n                logger.error(error_msg)\n                raise ValueError(error_msg)\n            \n            # Store the transcript metadata\n            transcript_metadata = {\n                \"memory_id\": f\"transcript_{transcript_id}\",\n                \"transcript_id\": transcript_id,\n                \"format\": \"deepsearch\",\n                \"processed_at\": datetime.now().isoformat(),\n                \"message_count\": len(transcript_data),\n                \"status\": \"processed\"\n            }\n            \n            if metadata:\n                transcript_metadata.update(metadata)\n            \n            # Store in memory system\n            try:\n                self.memory.store(\n                    content={\"deepsearch_sections\": transcript_data},\n                    context_id=self.transcript_context_id,\n                    metadata=transcript_metadata,\n                    tags=[\"transcript\", \"deepsearch\"],\n                    initial_tier=TIER_REFERENCE\n                )\n            except Exception as e:\n                logger.error(f\"Error storing transcript metadata: {str(e)}\")\n                \n                # Store in mock storage if memory system fails\n                if self.use_mock:\n                    self._transcripts[transcript_id] = {\n                        \"transcript_id\": transcript_id,\n                        \"content\": {\"deepsearch_sections\": transcript_data},\n                        \"metadata\": transcript_metadata,\n                        \"tags\": [\"transcript\", \"deepsearch\"]\n                    }\n            \n            # Process each DeepSearch section as a message\n            message_count = 0\n            \n            for section in transcript_data:\n                # Extract section data\n                section_id = section.get(\"id\", str(uuid.uuid4()))\n                summary = section.get(\"summary\", \"\")\n                tags = section.get(\"tags\", [])\n                text = section.get(\"text\", summary)\n                \n                # Parse confidence scores from summary\n                confidence_scores = []\n                clean_summary = summary\n                \n                # Extract confidence scores if present in [score1,score2,...] format\n                confidence_match = re.match(r'\\[([\\d\\.,]+)\\]\\s*(.*)', summary)\n                if confidence_match:\n                    confidence_str = confidence_match.group(1)\n                    clean_summary = confidence_match.group(2)\n                    \n                    try:\n                        confidence_scores = [float(score.strip()) for score in confidence_str.split(',')]\n                    except ValueError:\n                        logger.warning(f\"Failed to parse confidence scores: {confidence_str}\")\n                \n                # Convert DeepSearch tags to our tag format\n                our_tags = []\n                \n                for ds_tag in tags:\n                    tag_category = ds_tag.get(\"tag\", \"\").replace(\"#\", \"\")\n                    tag_topic = ds_tag.get(\"topic\", \"\")\n                    \n                    if tag_category and tag_topic:\n                        our_tag = f\"#{tag_category}_{tag_topic.upper()}\"\n                        our_tags.append(our_tag)\n                \n                # Generate a message ID based on section ID\n                message_id = f\"{transcript_id}_{section_id}\"\n                \n                # Add the message\n                self.add_message(\n                    transcript_id=transcript_id,\n                    content=text,\n                    message_type=\"transcript_section\",\n                    sender_id=\"deepsearch\",  # DeepSearch is considered the sender\n                    receiver_id=\"system\",\n                    message_id=message_id,\n                    tags=our_tags,\n                    metadata={\n                        \"position\": message_count,\n                        \"original_id\": section_id,\n                        \"confidence_scores\": confidence_scores,\n                        \"summary\": clean_summary\n                    }\n                )\n                \n                message_count += 1\n            \n            logger.info(f\"Processed DeepSearch transcript {transcript_id} with {message_count} sections\")\n            \n            return transcript_id\n        except Exception as e:\n            logger.error(f\"Error processing DeepSearch transcript {transcript_id}: {str(e)}\")\n            \n            # Create error transcript in mock storage\n            if self.use_mock:\n                self._transcripts[transcript_id] = {\n                    \"transcript_id\": transcript_id,\n                    \"error\": str(e),\n                    \"status\": \"error\",\n                    \"format\": \"deepsearch\",\n                    \"created_at\": datetime.now().isoformat()\n                }\n            \n            # Re-raise to be handled by the caller\n            raise\n    \n    def _process_pure_ai_transcript(self,\n                                   transcript_data: Union[str, List[Dict[str, Any]]],\n                                   transcript_id: str,\n                                   metadata: Optional[Dict[str, Any]] = None) -> str:\n        \"\"\"\n        Process a transcript in PURE_AI_LANGUAGE format\n        \n        Args:\n            transcript_data: Transcript data in PURE_AI_LANGUAGE format\n            transcript_id: Transcript identifier\n            metadata: Additional metadata\n            \n        Returns:\n            transcript_id: Identifier of the processed transcript\n        \"\"\"\n        logger.info(f\"Processing PURE_AI transcript {transcript_id}\")\n        \n        try:\n            # Parse PURE_AI format if provided as string\n            if isinstance(transcript_data, str):\n                try:\n                    transcript_data = json.loads(transcript_data)\n                except json.JSONDecodeError as e:\n                    error_msg = f\"Invalid PURE_AI format: {str(e)}\"\n                    logger.error(error_msg)\n                    raise ValueError(error_msg)\n            \n            # Convert to list if single message\n            if isinstance(transcript_data, dict):\n                transcript_data = [transcript_data]\n            \n            # Validate PURE_AI format\n            if not isinstance(transcript_data, list):\n                error_msg = \"PURE_AI transcript must be a list of messages\"\n                logger.error(error_msg)\n                raise ValueError(error_msg)\n            \n            # Store the transcript metadata\n            transcript_metadata = {\n                \"memory_id\": f\"transcript_{transcript_id}\",\n                \"transcript_id\": transcript_id,\n                \"format\": \"pure_ai\",\n                \"processed_at\": datetime.now().isoformat(),\n                \"message_count\": len(transcript_data),\n                \"status\": \"processed\"\n            }\n            \n            if metadata:\n                transcript_metadata.update(metadata)\n            \n            # Store in memory system\n            try:\n                self.memory.store(\n                    content={\"pure_ai_messages\": transcript_data},\n                    context_id=self.transcript_context_id,\n                    metadata=transcript_metadata,\n                    tags=[\"transcript\", \"pure_ai\"],\n                    initial_tier=TIER_REFERENCE\n                )\n            except Exception as e:\n                logger.error(f\"Error storing transcript metadata: {str(e)}\")\n                \n                # Store in mock storage if memory system fails\n                if self.use_mock:\n                    self._transcripts[transcript_id] = {\n                        \"transcript_id\": transcript_id,\n                        \"content\": {\"pure_ai_messages\": transcript_data},\n                        \"metadata\": transcript_metadata,\n                        \"tags\": [\"transcript\", \"pure_ai\"]\n                    }\n            \n            # Process each PURE_AI message\n            message_count = 0\n            \n            for message in transcript_data:\n                # Extract message data\n                message_id = message.get(\"message_id\", str(uuid.uuid4()))\n                message_type = message.get(\"message_type\", \"information\")\n                sender_id = message.get(\"sender_id\", \"unknown\")\n                receiver_id = message.get(\"receiver_id\", \"unknown\")\n                content = message.get(\"content\", {})\n                \n                # Extract tags from principles and tags fields\n                our_tags = []\n                \n                # Process project principles as tags\n                principles = message.get(\"project_principles\", [])\n                for principle in principles:\n                    # Convert principle to tag format if needed\n                    if not principle.startswith(\"#\"):\n                        principle = f\"#{principle}\"\n                    our_tags.append(principle)\n                \n                # Add existing tags\n                tags = message.get(\"tags\", [])\n                our_tags.extend(tags)\n                \n                # Extract truth and efficiency\n                confidence_score = None\n                truth_efficiency = message.get(\"truth_and_efficiency\", {})\n                if truth_efficiency:\n                    certainty_level = truth_efficiency.get(\"certainty_level\")\n                    if certainty_level is not None:\n                        confidence_score = certainty_level / 100.0\n                \n                # Add the message\n                self.add_message(\n                    transcript_id=transcript_id,\n                    content=content,\n                    message_type=message_type,\n                    sender_id=sender_id,\n                    receiver_id=receiver_id,\n                    message_id=message_id,\n                    tags=our_tags,\n                    metadata={\n                        \"position\": message_count,\n                        \"protocol_version\": message.get(\"protocol_version\"),\n                        \"confidence_score\": confidence_score\n                    }\n                )\n                \n                message_count += 1\n            \n            logger.info(f\"Processed PURE_AI transcript {transcript_id} with {message_count} messages\")\n            \n            return transcript_id\n        except Exception as e:\n            logger.error(f\"Error processing PURE_AI transcript {transcript_id}: {str(e)}\")\n            \n            # Create error transcript in mock storage\n            if self.use_mock:\n                self._transcripts[transcript_id] = {\n                    \"transcript_id\": transcript_id,\n                    \"error\": str(e),\n                    \"status\": \"error\",\n                    \"format\": \"pure_ai\",\n                    \"created_at\": datetime.now().isoformat()\n                }\n            \n            # Re-raise to be handled by the caller\n            raise\n    \n    def _process_structured_transcript(self,\n                                      transcript_data: Dict[str, Any],\n                                      transcript_id: str,\n                                      metadata: Optional[Dict[str, Any]] = None) -> str:\n        \"\"\"\n        Process a transcript in structured format\n        \n        Args:\n            transcript_data: Transcript data in structured format\n            transcript_id: Transcript identifier\n            metadata: Additional metadata\n            \n        Returns:\n            transcript_id: Identifier of the processed transcript\n        \"\"\"\n        logger.info(f\"Processing structured transcript {transcript_id}\")\n        \n        try:\n            # Parse structured format if provided as string\n            if isinstance(transcript_data, str):\n                try:\n                    transcript_data = json.loads(transcript_data)\n                except json.JSONDecodeError as e:\n                    error_msg = f\"Invalid structured format: {str(e)}\"\n                    logger.error(error_msg)\n                    raise ValueError(error_msg)\n            \n            # Validate structured format\n            if not isinstance(transcript_data, dict):\n                error_msg = \"Structured transcript must be a dictionary\"\n                logger.error(error_msg)\n                raise ValueError(error_msg)\n            \n            # Extract messages\n            messages = transcript_data.get(\"messages\", [])\n            \n            if not isinstance(messages, list):\n                error_msg = \"Structured transcript messages must be a list\"\n                logger.error(error_msg)\n                raise ValueError(error_msg)\n            \n            # Store the transcript metadata\n            transcript_metadata = {\n                \"memory_id\": f\"transcript_{transcript_id}\",\n                \"transcript_id\": transcript_id,\n                \"format\": \"structured\",\n                \"processed_at\": datetime.now().isoformat(),\n                \"message_count\": len(messages),\n                \"status\": \"processed\"\n            }\n            \n            # Add provided metadata\n            if metadata:\n                transcript_metadata.update(metadata)\n            \n            # Add transcript metadata from the structured data\n            transcript_meta = transcript_data.get(\"metadata\", {})\n            if transcript_meta:\n                transcript_metadata.update(transcript_meta)\n            \n            # Store in memory system\n            try:\n                self.memory.store(\n                    content={\"structured_transcript\": transcript_data},\n                    context_id=self.transcript_context_id,\n                    metadata=transcript_metadata,\n                    tags=[\"transcript\", \"structured\"],\n                    initial_tier=TIER_REFERENCE\n                )\n            except Exception as e:\n                logger.error(f\"Error storing transcript metadata: {str(e)}\")\n                \n                # Store in mock storage if memory system fails\n                if self.use_mock:\n                    self._transcripts[transcript_id] = {\n                        \"transcript_id\": transcript_id,\n                        \"content\": {\"structured_transcript\": transcript_data},\n                        \"metadata\": transcript_metadata,\n                        \"tags\": [\"transcript\", \"structured\"]\n                    }\n            \n            # Process each message\n            message_count = 0\n            \n            for message in messages:\n                # Extract message data\n                message_id = message.get(\"id\", str(uuid.uuid4()))\n                message_type = message.get(\"type\", \"message\")\n                sender_id = message.get(\"sender\", \"unknown\")\n                receiver_id = message.get(\"receiver\", \"unknown\")\n                content = message.get(\"content\", \"\")\n                timestamp = message.get(\"timestamp\")\n                tags = message.get(\"tags\", [])\n                \n                # Add the message\n                self.add_message(\n                    transcript_id=transcript_id,\n                    content=content,\n                    message_type=message_type,\n                    sender_id=sender_id,\n                    receiver_id=receiver_id,\n                    message_id=message_id,\n                    tags=tags,\n                    metadata={\n                        \"position\": message_count,\n                        \"timestamp\": timestamp\n                    }\n                )\n                \n                message_count += 1\n            \n            logger.info(f\"Processed structured transcript {transcript_id} with {message_count} messages\")\n            \n            return transcript_id\n        except Exception as e:\n            logger.error(f\"Error processing structured transcript {transcript_id}: {str(e)}\")\n            \n            # Create error transcript in mock storage\n            if self.use_mock:\n                self._transcripts[transcript_id] = {\n                    \"transcript_id\": transcript_id,\n                    \"error\": str(e),\n                    \"status\": \"error\",\n                    \"format\": \"structured\",\n                    \"created_at\": datetime.now().isoformat()\n                }\n            \n            # Re-raise to be handled by the caller\n            raise\n    \n    def _analyze_direction_patterns(self, messages: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"\n        Analyze communication direction patterns\n        \n        Args:\n            messages: List of messages\n            \n        Returns:\n            Analysis results\n        \"\"\"\n        try:\n            # Count messages by direction\n            direction_counts = {\n                DIRECTION_INTRA_AI: 0,\n                DIRECTION_INTER_AI: 0,\n                DIRECTION_HUMAN_AI: 0\n            }\n            \n            for message in messages:\n                tags = message.get(\"tags\", [])\n                \n                # Count by direction\n                if DIRECTION_INTRA_AI in tags:\n                    direction_counts[DIRECTION_INTRA_AI] += 1\n                elif DIRECTION_INTER_AI in tags:\n                    direction_counts[DIRECTION_INTER_AI] += 1\n                elif DIRECTION_HUMAN_AI in tags:\n                    direction_counts[DIRECTION_HUMAN_AI] += 1\n            \n            # Calculate percentages\n            total_messages = len(messages)\n            direction_percentages = {}\n            \n            for direction, count in direction_counts.items():\n                if total_messages > 0:\n                    percentage = (count / total_messages) * 100\n                else:\n                    percentage = 0\n                \n                direction_percentages[direction] = percentage\n            \n            return {\n                \"counts\": direction_counts,\n                \"percentages\": direction_percentages\n            }\n        except Exception as e:\n            logger.error(f\"Error analyzing direction patterns: {str(e)}\")\n            return {\n                \"counts\": {},\n                \"percentages\": {}\n            }\n    \n    def _analyze_purpose_patterns(self, messages: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"\n        Analyze communication purpose patterns\n        \n        Args:\n            messages: List of messages\n            \n        Returns:\n            Analysis results\n        \"\"\"\n        try:\n            # Count messages by purpose\n            purpose_counts = {\n                PURPOSE_CLARIFICATION: 0,\n                PURPOSE_IDEATION: 0,\n                PURPOSE_DECISION: 0,\n                PURPOSE_IMPLEMENTATION: 0,\n                PURPOSE_FEEDBACK: 0\n            }\n            \n            for message in messages:\n                tags = message.get(\"tags\", [])\n                \n                # Count by purpose\n                for purpose in purpose_counts.keys():\n                    if purpose in tags:\n                        purpose_counts[purpose] += 1\n            \n            # Calculate percentages\n            total_messages = len(messages)\n            purpose_percentages = {}\n            \n            for purpose, count in purpose_counts.items():\n                if total_messages > 0:\n                    percentage = (count / total_messages) * 100\n                else:\n                    percentage = 0\n                \n                purpose_percentages[purpose] = percentage\n            \n            return {\n                \"counts\": purpose_counts,\n                \"percentages\": purpose_percentages\n            }\n        except Exception as e:\n            logger.error(f\"Error analyzing purpose patterns: {str(e)}\")\n            return {\n                \"counts\": {},\n                \"percentages\": {}\n            }\n    \n    def _analyze_emotion_patterns(self, messages: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"\n        Analyze emotional patterns\n        \n        Args:\n            messages: List of messages\n            \n        Returns:\n            Analysis results\n        \"\"\"\n        try:\n            # Count messages by emotion\n            emotion_counts = {\n                EMOTION_EXCITEMENT: 0,\n                EMOTION_FRUSTRATION: 0,\n                EMOTION_SATISFACTION: 0,\n                EMOTION_CONFUSION: 0\n            }\n            \n            for message in messages:\n                tags = message.get(\"tags\", [])\n                \n                # Count by emotion\n                for emotion in emotion_counts.keys():\n                    if emotion in tags:\n                        emotion_counts[emotion] += 1\n            \n            # Calculate percentages\n            total_messages = len(messages)\n            emotion_percentages = {}\n            \n            for emotion, count in emotion_counts.items():\n                if total_messages > 0:\n                    percentage = (count / total_messages) * 100\n                else:\n                    percentage = 0\n                \n                emotion_percentages[emotion] = percentage\n            \n            return {\n                \"counts\": emotion_counts,\n                \"percentages\": emotion_percentages\n            }\n        except Exception as e:\n            logger.error(f\"Error analyzing emotion patterns: {str(e)}\")\n            return {\n                \"counts\": {},\n                \"percentages\": {}\n            }\n    \n    def _analyze_action_patterns(self, messages: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"\n        Analyze action patterns\n        \n        Args:\n            messages: List of messages\n            \n        Returns:\n            Analysis results\n        \"\"\"\n        try:\n            # Count messages by action\n            action_counts = {\n                ACTION_REQUESTED: 0,\n                ACTION_ASSIGNED: 0,\n                ACTION_COMPLETED: 0,\n                ACTION_BLOCKED: 0\n            }\n            \n            for message in messages:\n                tags = message.get(\"tags\", [])\n                \n                # Count by action\n                for action in action_counts.keys():\n                    if action in tags:\n                        action_counts[action] += 1\n            \n            # Calculate percentages\n            total_messages = len(messages)\n            action_percentages = {}\n            \n            for action, count in action_counts.items():\n                if total_messages > 0:\n                    percentage = (count / total_messages) * 100\n                else:\n                    percentage = 0\n                \n                action_percentages[action] = percentage\n            \n            # Calculate completion rate\n            requested = action_counts[ACTION_REQUESTED] + action_counts[ACTION_ASSIGNED]\n            completed = action_counts[ACTION_COMPLETED]\n            \n            if requested > 0:\n                completion_rate = (completed / requested) * 100\n            else:\n                completion_rate = 0\n            \n            return {\n                \"counts\": action_counts,\n                \"percentages\": action_percentages,\n                \"completion_rate\": completion_rate\n            }\n        except Exception as e:\n            logger.error(f\"Error analyzing action patterns: {str(e)}\")\n            return {\n                \"counts\": {},\n                \"percentages"
  ],
  "source": "claude",
  "timestamp": "2025-03-10T23:31:32.100146Z",
  "data_type": "message",
  "metadata": {
    "author": "assistant"
  }
}