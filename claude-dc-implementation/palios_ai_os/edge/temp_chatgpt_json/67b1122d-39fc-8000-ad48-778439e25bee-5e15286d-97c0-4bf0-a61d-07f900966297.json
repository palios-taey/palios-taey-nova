{"data_id": "67b1122d-39fc-8000-ad48-778439e25bee-5e15286d-97c0-4bf0-a61d-07f900966297", "content": ["{\"name\": \"firestore_execution_listener\", \"updates\": [{\"pattern\": \".*\", \"multiple\": true, \"replacement\": \"import firebase_admin\\nfrom firebase_admin import credentials, firestore\\nfrom flask import Flask, request, jsonify\\n\\n# Path to Firebase service account key JSON file\\nkey_file_path = r\\\"C:\\\\AI-Execution-System\\\\firebase_key.json\\\"\\n\\n# Initialize Firebase Admin SDK\\ncred = credentials.Certificate(key_file_path)\\nfirebase_admin.initialize_app(cred)\\n\\ndb = firestore.client()\\napp = Flask(__name__)\\n\\n# Route to retrieve documents from a collection\\n@app.route('/get_documents', methods=['GET'])\\ndef get_documents():\\n    collection_name = request.args.get('collection')\\n    if not collection_name:\\n        return jsonify({\\\"error\\\": \\\"Collection name is required\\\"}), 400\\n    \\n    try:\\n        docs = db.collection(collection_name).stream()\\n        data = {doc.id: doc.to_dict() for doc in docs}\\n        return jsonify(data)\\n    except Exception as e:\\n        return jsonify({\\\"error\\\": str(e)}), 500\\n\\n# Route to update a document in Firestore\\n@app.route('/update_document', methods=['POST'])\\ndef update_document():\\n    data = request.json\\n    collection_name = data.get(\\\"collection\\\")\\n    doc_id = data.get(\\\"doc_id\\\")\\n    update_data = data.get(\\\"update_data\\\")\\n    \\n    if not collection_name or not doc_id or not update_data:\\n        return jsonify({\\\"error\\\": \\\"collection, doc_id, and update_data are required\\\"}), 400\\n    \\n    try:\\n        doc_ref = db.collection(collection_name).document(doc_id)\\n        doc_ref.set(update_data, merge=True)\\n        return jsonify({\\\"success\\\": f\\\"Document {doc_id} updated successfully\\\"})\\n    except Exception as e:\\n        return jsonify({\\\"error\\\": str(e)}), 500\\n\\n# Route to validate Firestore schema\\n@app.route('/validate_schema', methods=['GET'])\\ndef validate_schema():\\n    schema_structure = {\\n        \\\"goals\\\": [\\\"name\\\", \\\"tags\\\", \\\"description\\\", \\\"priority_level\\\", \\\"timeframe\\\", \\\"ai_strategy_notes\\\", \\\"target_date\\\", \\\"creation_date\\\", \\\"last_modified\\\", \\\"core_principles_values\\\", \\\"life_optimization\\\", \\\"ai_workflows_experiments\\\", \\\"mind_map\\\"],\\n        \\\"principles\\\": [\\\"name\\\", \\\"tags\\\", \\\"priority\\\", \\\"description\\\", \\\"related_goals\\\", \\\"related_execution_logs\\\", \\\"related_charter\\\", \\\"related_mind_map\\\", \\\"creation_date\\\", \\\"last_updated\\\"]\\n    }\\n    \\n    schema_validation = {}\\n    try:\\n        for collection, expected_fields in schema_structure.items():\\n            docs = db.collection(collection).limit(1).stream()\\n            for doc in docs:\\n                existing_data = doc.to_dict()\\n                missing_fields = [field for field in expected_fields if field not in existing_data]\\n                schema_validation[collection] = {\\\"missing_fields\\\": missing_fields}\\n        return jsonify(schema_validation)\\n    except Exception as e:\\n        return jsonify({\\\"error\\\": str(e)}), 500\\n\\n# Route to fix missing schema fields\\n@app.route('/fix_schema', methods=['POST'])\\ndef fix_schema():\\n    schema_structure = {\\n        \\\"goals\\\": [\\\"name\\\", \\\"tags\\\", \\\"description\\\", \\\"priority_level\\\", \\\"timeframe\\\", \\\"ai_strategy_notes\\\", \\\"target_date\\\", \\\"creation_date\\\", \\\"last_modified\\\", \\\"core_principles_values\\\", \\\"life_optimization\\\", \\\"ai_workflows_experiments\\\", \\\"mind_map\\\"],\\n        \\\"principles\\\": [\\\"name\\\", \\\"tags\\\", \\\"priority\\\", \\\"description\\\", \\\"related_goals\\\", \\\"related_execution_logs\\\", \\\"related_charter\\\", \\\"related_mind_map\\\", \\\"creation_date\\\", \\\"last_updated\\\"]\\n    }\\n    \\n    try:\\n        for collection, expected_fields in schema_structure.items():\\n            docs = db.collection(collection).stream()\\n            for doc in docs:\\n                doc_ref = db.collection(collection).document(doc.id)\\n                existing_data = doc.to_dict()\\n                missing_fields = {field: \\\"N/A\\\" for field in expected_fields if field not in existing_data}\\n                if missing_fields:\\n                    doc_ref.set(missing_fields, merge=True)\\n        return jsonify({\\\"success\\\": \\\"Firestore schema corrected successfully!\\\"})\\n    except Exception as e:\\n        return jsonify({\\\"error\\\": str(e)}), 500\\n\\nif __name__ == '__main__':\\n    app.run(host='0.0.0.0', port=5001, debug=True)\"}]}"], "source": "ChatGPT", "timestamp": 1739752886.858576, "data_type": "conversation", "metadata": {"author": "assistant", "original_conversation_id": "67b1122d-39fc-8000-ad48-778439e25bee"}}